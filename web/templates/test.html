<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Draw Canvas</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
		<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> -->
		
		<!-- <link rel="styles&heet" type="text/css" href="main.css"> -->
		
		<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
		<!-- <link rel="stylesheet" type="text/css" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" /> -->
		
		<!-- <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script> -->
		<script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>
		
		<!-- Latest compiled and minified CSS -->
		<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-select@1.13.9/dist/css/bootstrap-select.min.css"> -->

		<!-- Latest compiled and minified JavaScript -->
		<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap-select@1.13.9/dist/js/bootstrap-select.min.js"></script> -->

		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/89/three.js"></script>
		
		<script type="text/javascript" src="http://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
		<script type="text/javascript" src="http://static.robotwebtools.org/roslibjs/current/roslib.min.js"></script>

		<link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
		
		
	</head>

	<body>
		<script>
			function onChangeSelect() {
				
				console.log($("#selectCalibTarget").val());
				console.log(document.getElementById("selectCalibTarget"))
				console.log(document.getElementById("selectCalibTarget").value);
				// if($("select[name='selectCalibTarget']").val()=="plane")
				// {
				// 	$('#colorsCalibration').hide();
				// 	$('#planeCalibration').show();
				// }
				// else
				// {
				// 	$('#colorsCalibration').show();
				// 	$('#planeCalibration').hide();
				// }
			};
		</script>
		<style type="text/css">
			#container {       
				width: 85%;
				height: 100%;
				position: fixed;
				z-index: 1;
				overflow-x: hidden;
				top: 0;
				left: 0;
				float: right;
			}
			#buttonator {
				width: 15%;
				height: 100%;
				position: fixed;
				z-index: 1;
				overflow-x: hidden;
				top: 0;
				right: 0;
				float: right;
				/*display: none;*/
				/* float:right;
				width:50px;
				height:100px; */
			}		
			.button {
				background-size: 100% 100%;
				height: 100px;
				width: 100%;
				padding-bottom: 10px;
				/* text-align: center; */
				/* text-decoration: none;
				display: inline-block; */
				font-size: 16px;
			}
			canvas { 
				width: 100%;
        		height: 100%;
				/*margin: auto;
				padding: 10px 10px 10px 10px; */
				display: block;
			}
			#colorsCalibration{
				display:none;
			}
			.settings{
				display:block;
				height:50px;
				width:50px;
				margin:10px;
				cursor:pointer;
			}
			.calibrate{
				display:block;
				height:100px;
				width:100%;
				margin:10px;
				cursor:pointer;
			}
		</style>
		<div id="container">
		  <canvas></canvas>
		</div>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - interactive - raycasting - points </div>
		<div id="buttonator" style="overflow-y:auto;">
			<div class="settings" data-toggle="popover" data-mysettings="#someid" data-original-title="A Title"> 
				<i class="fa fa-bars"></i>
			</div>
			<div id="someid" style="display: none">
				<select id='list'>
					<option value='1'>First</option>
					<option value='2'>Second</option>
					<option value='3'>Third</option>
				</select>
			</div>

			
				
			
			
			<span id="result">

			</span> 
			<button type="button" id="addPath" class="button"><div>Add Path</div></button>
			<button type="button" id="removePath" class="button"><div>Remove Path</div></button>
			<button type="button" id="removeAll" class="button"><div>Remove All</div></button>
			<!-- <button type="button" id="calibrate"  data-toggle="popover" class="button">Calibrate</button> -->
			<!-- id="calibrate" -->
			<div class="calibrate" data-toggle="popover" data-target="#my-popover-content"> 
				<i class="fa fa-bars"></i>
			</div>
			<script type="text/html" id="my-popover-content">	
				<div id="calibrationForm"> 
					<!-- class="hidden"> -->
					<label>What do you want to calibrate?
					</label>
					<select id="selectCalibTarget">
					<!-- </select> onchange="onChangeSelect()"> -->
						<option value="plane">Plane</option>
						<option value="colors">Colors</option>
						<option value="homing">Homing</option>
					</select>	
					<div id="planeCalibration" class="form-group">
						<select name="selectPlaneCalibTarget" id="selectPlaneCalibTarget" class="selectpicker">
							<option value="origin">origin</option>
							<option value="xAxis">X axis</option>
							<option value="yAxis">Y axis</option>
						</select>
					</div>
					<div id="colorsCalibration" class="form-group">
						<select name="selectColorsCalibTarget" id="selectColorsCalibTarget" class="selectpicker">
							<option value="origin">origin</option>
							<option value="xAxis">X axis</option>
							<option value="yAxis">Y axis</option>
						</select>
					</div>
				</div>	
			</script>
			<button type="button" id="setParameters" data-toggle="popover" class="button"><div>Set Parameters</div></button>
			<div id="parametersForm" class="hide">
				<label for="selectBehavior">Behavior to set:</label>
				<select name="selectBehavior" id="selectBehavior" class="form-control form-control-sm">
					<option value="movingBehavior">Moving behavior</option>
					<option value="stationaryBehavior">Stationary behavior</option>
				</select>	
				<div class="row">
					<div class="col-md-6">
						<label for="Kx">Kx (N/m):</label>
						<input type="number" name="Kx" id="Kx" value="1200" step="100" class="form-control form-control-sm">
						<label for="Ky">Ky (N/m):</label>
						<input type="number" name="Ky" id="Ky" value="1200" step="100" class="form-control form-control-sm">
						<label for="Kz">Kz (N/m):</label>
						<input type="number" name="Kz" id="Kz" value="1200" step="100" class="form-control form-control-sm ">
					</div>
					<div class="col-xs-6">
							<label for="Rx">Rx (Nm/rad):</label>
							<input type="number" name="Rx" id="Rx" value="200" step="10" class="form-control form-control-sm ">
							<label for="Ry">Ry (Nm/rad):</label>
							<input type="number" name="Ry" id="Ry" value="200" step="10" class="form-control form-control-sm ">
							<label for="Rz">Rz (Nm/rad):</label>
							<input type="number" name="Rz" id="Rz" value="0" step="10" class="form-control form-control-sm">	
					</div>
				</div>
				<label for="Fz">Fz (N):</label>
				<input type="number" name="Fz" id="Fz" value="-1" step="0.1" class="form-control input-md">
				<label for="baseLink">base link:</label>
				<input type="text" name="baseLink" id="baseLink" value="base_link"class="form-control input-md">
				<label for="distalLink">distal link:</label>
				<input type="text" name="distalLink" id="distalLink" value="TCP"class="form-control input-md">
				<label for="desiredVelocity">desired velocity (m/s):</label>
				<input type="number" name="desiredVelocity" id="desiredVelocity" value="0.05" step="0.01" class="form-control input-md">
				<button type="button" class="btn btn-primary" data-loading-text="Sending info.."><em class="icon-ok"></em> Set Parameters</button>
			</div>
			<!-- <div id="result"></div> -->
		</div>

		<script type=text/javascript>
			$SCRIPT_ROOT = "{{ url_for('index', _external=True) }}";
		</script>

		<script type="module">
			// import * as THREE from '../build/three.module.js';
			// import Stats from './jsm/libs/stats.module.js';
			var canvas;
      		var renderer, scene, camera, stats;
      		var plane;
			var raycaster;
			var mouse = new THREE.Vector2();
			var dblClick = new THREE.Vector2();
			var previousPoint; 
			var distanceThreshold = 0.5; 
			var tailSpheres = [];
      		var drawPoints = [];
			var segments = [];
			var paths = [];  
			var spheresIndex = 0;
			var clock;
			var raycast_threshold = 0.1;
			var pointSize = 0.05;
			
			let mouseDown = false;

			var ros = new ROSLIB.Ros({
				url : 'ws://10.24.8.100:9090'
			});

			ros.on('connection', function() {
				console.log('Connected to websocket server.');
			});

			ros.on('error', function(error) {
				console.log('Error connecting to websocket server: ', error);
			});

			ros.on('close', function() {
				console.log('Connection to websocket server closed.');
			});

			var jointstate_listener = new ROSLIB.Topic({
				ros : ros,
				name : '/xbotcore/joint_states',
				messageType : 'xbot_msgs/JointState'
			});

			jointstate_listener.subscribe(function(m) {
				console.log(m.link_position);
			});
			
			window.onload = function() {
				var removePathBtn = document.getElementById('removePath');
				var addPathBtn = document.getElementById('addPath');
				var removeAllBtn = document.getElementById('removeAll');

				addPathBtn.onclick = function() {addPath()};
				removePathBtn.onclick = function() {removePath()};
				removeAllBtn.onclick = function() {removeAll()};

				// $(document).on('change','#selectCalibTarget', function () {
				// 	$('#result').text($('#selectCalibTarget option:selected').val());
				// 	console.log($('#selectCalibTarget option:selected').val());
				// })

				// $(function(){
				// 	$('#calibrate').popover({
					
				// 		placement: 'left',
				// 		title: 'Calibrate',
				// 		html:true,
				// 		container: 'body',
				// 		//trigger: 'focus',
				// 		content: $('#calibrationForm').html()
				// 	}).on('click', function(){
						
				// 	})
				// });
				
				var $popovercalibrate = $('.calibrate').popover({
					html: true,
					placement: 'left',
					container: 'body',
					content: function () {
						var myCalibForm = $(this).data().target;
						return $(myCalibForm).html();
					}
				});

				// var $popoversettings = $('.settings').popover({
				// 	html: true,
				// 	placement: 'right',
				// 	content: function () {
				// 		var mySettings = $(this).data('mysettings');
				// 		return $(mySettings).html();
				// 	}
				// });


				$(':not(#anything)').on('click', function (e) {
					// $popoversettings.each(function () {
					// 	if (!$(this).is(e.target) && $(this).has(e.target).length === 0 && $('.popover').has(e.target).length === 0) {
					// 		$(this).popover('hide');
					// 		return;
					// 	}
					// });
					$popovercalibrate.each(function () {
						if (!$(this).is(e.target) && $(this).has(e.target).length === 0 && $('.popover').has(e.target).length === 0) {
							$(this).popover('hide');
							return;
						}
					});
					
				});


				// $(document).on('change','#list', function () {
				// 	$('#result').text($('#list option:selected').val());
				// });

				$(document).on('change','#selectCalibTarget', function () {
					$('#result').text($('#selectCalibTarget option:selected').val());
					alert($('#selectCalibTarget option:selected').val());
				});
			}
		
			init();
			animate();

			function init() {
				var container = document.getElementById( 'container' );
				scene = new THREE.Scene();
				console.log(scene.position);
				clock = new THREE.Clock();
				camera = new THREE.PerspectiveCamera( 70, 1, 1, 1000 );
				camera.position.set( 0, 6, 0 );
				camera.lookAt( scene.position );
				camera.updateMatrix();
        
				scene.background = new THREE.Color(0xf0f0f0);
				scene.add(new THREE.HemisphereLight(0x443333, 0x111122));

				var geometry = new THREE.PlaneBufferGeometry(20, 20);
				geometry.rotateX(- Math.PI / 2);
				var material = new THREE.ShadowMaterial({ opacity: 0.2 });
				plane = new THREE.Mesh(geometry, material);
				plane.position.y = 0;
				plane.receiveShadow = true;
				scene.add(plane);

				var helper = new THREE.GridHelper(20, 200);
				helper.position.y = 0;
				scene.add(helper);

				var worldAxis = new THREE.AxesHelper(1);
				scene.add(worldAxis);
        
				var sphereGeometry = new THREE.SphereBufferGeometry( 0.1, 32, 32 );
				var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
				for ( var i = 0; i < 40; i ++ ) {
					var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
					scene.add( sphere );
					tailSpheres.push( sphere );
				}
				
				renderer = new THREE.WebGLRenderer({canvas: document.querySelector("canvas"), antialias: true } );
				canvas = renderer.domElement;

				raycaster = new THREE.Raycaster();
				raycaster.params.Points.threshold = raycast_threshold;

				//onWindowResize();
				//window.addEventListener( 'resize', onWindowResize, false );
				canvas.addEventListener( 'dblclick', onCanvasDoubleClick, false );
				canvas.addEventListener( 'mousemove', onCanvasMouseMove, false );
				canvas.addEventListener('mousedown', onCanvasMouseDown, false);
				canvas.addEventListener('mouseup', onCanvasMouseUp, false)
			};

			

			$(function(){
				$('#setParameters').popover({
				
					placement: 'left',
					title: 'Set Control Parameters',
					html:true,
					container: 'body',
					//trigger: 'focus',
					content: $('#parametersForm').html()
				}).on('click', function(){

					// s
					console.log(e);
					// had to put it within the on click action so it grabs the correct info on submit
					$('.btn-primary').click(function(){
						$('#result').after("Parameters for " + $('#selectBehavior').val() + "set!")
						$.ajax({
							url: $SCRIPT_ROOT + 'sendCommands/',
							data: {
								'behavior': $('#selectBehavior').val(), 
								'Kx': $('#Kx').val(),
								'Ky': $('#Ky').val(),
								'Kz': $('#Kz').val(),
								'Rx': $('#Rx').val(),
								'Ry': $('#Ry').val(),
								'Rz': $('#Rz').val(),
								'Fz': $('#Fz').val(),
								'baseLink': $('#baseLink').val(),
								'distalLink': $('#distalLink').val(),
								'desiredVelocity': $('#desiredVelocity').val()},
							method: 'POST',
							success: function(data) {
								console.log(data)
								//$('#setParameters').popover('hide')
								//callback()           
							},
							async: true //async_bool
						});  
						
					})
				})
			})
			
			// $(function(){
			// 	$('#calibrate').popover({
				
			// 		placement: 'left',
			// 		title: 'Calibrate',
			// 		html:true,
			// 		container: 'body',
			// 		//trigger: 'focus',
			// 		content: $('#calibrationForm').html()
			// 	}).on('click', function(){
					
			// 	})
			// });
			

			function onCanvasDoubleClick( event ) {
				event.preventDefault();
				dblClick.x = ( event.clientX / canvas.width ) * 2 - 1;
				dblClick.y = - ( event.clientY / canvas.height ) * 2 + 1;
				addPoint(dblClick);	
			};
			  
			function onCanvasMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / canvas.width ) * 2 - 1;
				mouse.y = - ( event.clientY / canvas.height ) * 2 + 1;
				if(mouseDown){
					continuousDraw();
				}
			};

			function onCanvasMouseDown() {
				event.preventDefault();
				mouseDown = true;
				var intersection = projectOnPlane(mouse);
				previousPoint = intersection.point;
			}
			function onCanvasMouseUp() {
				event.preventDefault();
				mouseDown = false;
			}

			function addPath() {
				console.log("add path");
				segments.forEach(function (arrayItem) {
					console.log(arrayItem.geometry.boundingSphere.radius);
				});
				var path = {points: drawPoints, segments: segments};
				paths.push(path);
				drawPoints = [];
				segments = [];
			};
			
			function removePath() {
				console.log("remove path");
				var lastPath = paths.pop();
				var lastPoints = lastPath.points;
				var lastSegments = lastPath.segments;
				lastPoints.forEach(removeFromScene);
				lastSegments.forEach(removeFromScene);
				console.log(paths);
			};

			function removeAll() {
				for (var i = paths.length; i > 0 ; i--) {
					removePath();
				};
				console.log(paths)
			}

			function removeFromScene(item, index) {
				scene.remove(item);
			}
	  
			function continuousDraw(){
				var intersection = projectOnPlane(mouse);
				var mouseOnPlane = intersection.point;
				
				if ( mouseOnPlane == null || previousPoint == null) return
				
				var distance = previousPoint.distanceTo(mouseOnPlane);
				//console.log(distance)
				if (drawPoints.length == 0 && distance != 0){
					addPoint(mouse);
					//previousPoint = drawPoints[-1].position;
				}
				if (distance > distanceThreshold){
					console.log(distance)
					addPoint(mouse);
					//previousPoint = drawPoints[-1].position;
				}
			}

			function projectOnPlane(point){
				raycaster.setFromCamera( point, camera );
				var intersections = raycaster.intersectObject( plane );
				var intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
				
				return intersection
			}

			function addPoint(point){
				var sphereGeometry = new THREE.SphereBufferGeometry( 0.1, 32, 32 );
				var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0x363cfb } );
				var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
				var intersection = projectOnPlane(point);
				if ( intersection !== null ) {
					sphere.position.copy( intersection.point );
					sphere.scale.set( 1, 1, 1 );
					scene.add( sphere );
					drawPoints.push( sphere );
					previousPoint = intersection.point;
				}

				var geometry = new THREE.Geometry();
				if(drawPoints.length>1){
					var last_sphere = drawPoints[drawPoints.length - 2];
					geometry.vertices.push(last_sphere.position);
					geometry.vertices.push(sphere.position);
					console.log(last_sphere.position.distanceTo(sphere.position));
					var material = new THREE.LineBasicMaterial( { color: 0x000000 } );
					var line = new THREE.Line( geometry, material );
					scene.add(line);
					segments.push(line);
				}
			};

			function onWindowResize() {

			};
			
			function resizeCanvasToDisplaySize() {
				// look up the size the canvas is being displayed
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				// adjust displayBuffer size to match
				if (canvas.width !== width || canvas.height !== height) {
					// you must pass false here or three.js sadly fights the browser
					renderer.setSize(width, height, false);
					camera.aspect = width / height;
					camera.updateProjectionMatrix();

					// update any render target sizes here
				}
			};
      
			function animate() {
				requestAnimationFrame( animate );
				render();
				// stats.update();
			};
			var toggle = 0;
			function render() {
				resizeCanvasToDisplaySize();
				var intersection = projectOnPlane(mouse);
				if ( toggle > 0.02 && intersection !== null ) {
					tailSpheres[ spheresIndex ].position.copy( intersection.point );
					tailSpheres[ spheresIndex ].scale.set( 1, 1, 1 );
					spheresIndex = ( spheresIndex + 1 ) % tailSpheres.length;
					toggle = 0;
				}
				for ( var i = 0; i < tailSpheres.length; i ++ ) {
					var sphere = tailSpheres[ i ];
					sphere.scale.multiplyScalar( 0.98 );
					sphere.scale.clampScalar( 0.01, 1 );
				}
        
				toggle += clock.getDelta();
				renderer.render( scene, camera );
			};
			
		</script>

	</body>

</html>