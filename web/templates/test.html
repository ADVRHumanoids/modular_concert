<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive - raycasting - points</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<style type="text/css">
			#container {       
				width: 85%;
				height: 100%;
				position: fixed;
				z-index: 1;
				overflow-x: hidden;
				top: 0;
				left: 0;
				float: right;
			}
			#buttonator {
				width: 15%;
				height: 100%;
				position: fixed;
				z-index: 1;
				overflow-x: hidden;
				top: 0;
				right: 0;
				float: right;
				/*display: none;*/
				/* float:right;
				width:50px;
				height:100px; */
			}		
			.button {
				background-size: 100% 100%;
				height: 100px;
				width: 100%;
				padding-bottom: 10px;
				/* text-align: center; */
				/* text-decoration: none;
				display: inline-block; */
				font-size: 16px;
			}
			canvas { 
				width: 100%;
        		height: 100%;
				/*margin: auto;
				padding: 10px 10px 10px 10px; */
				display: block;
			}
			.dropdown-content {
				display: none;
				position: absolute;
				background-color: #f1f1f1;
				/* min-width: 160px; */
				width: 100%;
				box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
				z-index: 1;
			}

			/* Links inside the dropdown */
			.dropdown-content a {
				color: black;
				padding: 12px 16px;
				text-decoration: none;
				display: block;
			}

			a {
				font-family: Ubuntu;
			}

			/* Change color of dropdown links on hover */
			.dropdown-content a:hover {background-color: #ddd;}

			/* Show the dropdown menu on hover */
			.dropdown:hover .dropdown-content {display: block;}

			/* Change the background color of the dropdown button when the dropdown content is shown */
			.dropdown:hover .dropdown {background-color: #10b4b9;}
		</style>
		<div id="container">
		  <canvas></canvas>
		</div>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - interactive - raycasting - points </div>
		<div id="buttonator" style="overflow-y:auto;">
			<button type="button" id="addPath" class="button"><div>Add Path</div></button>
			<button type="button" id="removePath" class="button"><div>Remove Path</div></button>
			<button type="button" id="removeAll" class="button"><div>Remove All</div></button>
			<div class="dropdown button">
				<button type="button" id="calibrate" class="button">Calibrate</button>
				<div class="dropdown-content">
					<a href="#">Plane</a>
					<a href="#">Colors</a>
					<a href="#">Homing</a>
				</div>
			</div>

		</div>

    	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/89/three.js"></script>
		<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
		<script type="text/javascript" src="http://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
		<script type="text/javascript" src="http://static.robotwebtools.org/roslibjs/current/roslib.min.js"></script>

		<script type="module">
			// import * as THREE from '../build/three.module.js';
			// import Stats from './jsm/libs/stats.module.js';
			var canvas;
      		var renderer, scene, camera, stats;
      		var plane;
			var raycaster;
			var mouse = new THREE.Vector2();
			var dblClick = new THREE.Vector2();
			var previousPoint; 
			var distanceThreshold = 0.5; 
			var tailSpheres = [];
      		var drawPoints = [];
			var segments = [];
			var paths = [];  
			var spheresIndex = 0;
			var clock;
			var raycast_threshold = 0.1;
			var pointSize = 0.05;
			
			let mouseDown = false;

			var ros = new ROSLIB.Ros({
				url : 'ws://10.24.8.100:9090'
			});

			ros.on('connection', function() {
				console.log('Connected to websocket server.');
			});

			ros.on('error', function(error) {
				console.log('Error connecting to websocket server: ', error);
			});

			ros.on('close', function() {
				console.log('Connection to websocket server closed.');
			});

			var jointstate_listener = new ROSLIB.Topic({
				ros : ros,
				name : '/xbotcore/joint_states',
				messageType : 'xbot_msgs/JointState'
			});

			jointstate_listener.subscribe(function(m) {
				console.log(m.link_position);
			});
			
			window.onload = function() {
				var removePathBtn = document.getElementById('removePath');
				var addPathBtn = document.getElementById('addPath');
				var removeAllBtn = document.getElementById('removeAll');

				addPathBtn.onclick = function() {addPath()};
				removePathBtn.onclick = function() {removePath()};
				removeAllBtn.onclick = function() {removeAll()};
			}
		
			init();
			animate();

			function init() {
				var container = document.getElementById( 'container' );
				scene = new THREE.Scene();
				console.log(scene.position);
				clock = new THREE.Clock();
				camera = new THREE.PerspectiveCamera( 70, 1, 1, 1000 );
				camera.position.set( 0, 6, 0 );
				camera.lookAt( scene.position );
				camera.updateMatrix();
        
				scene.background = new THREE.Color(0xf0f0f0);
				scene.add(new THREE.HemisphereLight(0x443333, 0x111122));

				var geometry = new THREE.PlaneBufferGeometry(20, 20);
				geometry.rotateX(- Math.PI / 2);
				var material = new THREE.ShadowMaterial({ opacity: 0.2 });
				plane = new THREE.Mesh(geometry, material);
				plane.position.y = 0;
				plane.receiveShadow = true;
				scene.add(plane);

				var helper = new THREE.GridHelper(20, 200);
				helper.position.y = 0;
				scene.add(helper);

				var worldAxis = new THREE.AxesHelper(1);
				scene.add(worldAxis);
        
				var sphereGeometry = new THREE.SphereBufferGeometry( 0.1, 32, 32 );
				var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
				for ( var i = 0; i < 40; i ++ ) {
					var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
					scene.add( sphere );
					tailSpheres.push( sphere );
				}
				
				renderer = new THREE.WebGLRenderer({canvas: document.querySelector("canvas"), antialias: true } );
				canvas = renderer.domElement;

				raycaster = new THREE.Raycaster();
				raycaster.params.Points.threshold = raycast_threshold;

				//onWindowResize();
				//window.addEventListener( 'resize', onWindowResize, false );
				canvas.addEventListener( 'dblclick', onCanvasDoubleClick, false );
				canvas.addEventListener( 'mousemove', onCanvasMouseMove, false );
				canvas.addEventListener('mousedown', onCanvasMouseDown, false);
				canvas.addEventListener('mouseup', onCanvasMouseUp, false)

			};

			

			
			function onCanvasDoubleClick( event ) {
				event.preventDefault();
				dblClick.x = ( event.clientX / canvas.width ) * 2 - 1;
				dblClick.y = - ( event.clientY / canvas.height ) * 2 + 1;
				addPoint(dblClick);	
			};
			  
			function onCanvasMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / canvas.width ) * 2 - 1;
				mouse.y = - ( event.clientY / canvas.height ) * 2 + 1;
				if(mouseDown){
					continuousDraw();
				}
			};

			function onCanvasMouseDown() {
				event.preventDefault();
				mouseDown = true;
				var intersection = projectOnPlane(mouse);
				previousPoint = intersection.point;
			}
			function onCanvasMouseUp() {
				event.preventDefault();
				mouseDown = false;
			}

			function addPath() {
				console.log("add path");
				segments.forEach(function (arrayItem) {
					console.log(arrayItem.geometry.boundingSphere.radius);
				});
				var path = {points: drawPoints, segments: segments};
				paths.push(path);
				drawPoints = [];
				segments = [];
			};
			
			function removePath() {
				console.log("remove path");
				var lastPath = paths.pop();
				var lastPoints = lastPath.points;
				var lastSegments = lastPath.segments;
				lastPoints.forEach(removeFromScene);
				lastSegments.forEach(removeFromScene);
				console.log(paths);
			};

			function removeAll() {
				for (var i = paths.length; i > 0 ; i--) {
					removePath();
				};
				console.log(paths)
			}

			function removeFromScene(item, index) {
				scene.remove(item);
			}
	  
			function continuousDraw(){
				var intersection = projectOnPlane(mouse);
				var mouseOnPlane = intersection.point;
				
				if ( mouseOnPlane == null || previousPoint == null) return
				
				var distance = previousPoint.distanceTo(mouseOnPlane);
				//console.log(distance)
				if (drawPoints.length == 0 && distance != 0){
					addPoint(mouse);
					//previousPoint = drawPoints[-1].position;
				}
				if (distance > distanceThreshold){
					console.log(distance)
					addPoint(mouse);
					//previousPoint = drawPoints[-1].position;
				}
			}

			function projectOnPlane(point){
				raycaster.setFromCamera( point, camera );
				var intersections = raycaster.intersectObject( plane );
				var intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
				
				return intersection
			}

			function addPoint(point){
				var sphereGeometry = new THREE.SphereBufferGeometry( 0.1, 32, 32 );
				var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0x363cfb } );
				var sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
				var intersection = projectOnPlane(point);
				if ( intersection !== null ) {
					sphere.position.copy( intersection.point );
					sphere.scale.set( 1, 1, 1 );
					scene.add( sphere );
					drawPoints.push( sphere );
					previousPoint = intersection.point;
				}

				var geometry = new THREE.Geometry();
				if(drawPoints.length>1){
					var last_sphere = drawPoints[drawPoints.length - 2];
					geometry.vertices.push(last_sphere.position);
					geometry.vertices.push(sphere.position);
					console.log(last_sphere.position.distanceTo(sphere.position));
					var material = new THREE.LineBasicMaterial( { color: 0x000000 } );
					var line = new THREE.Line( geometry, material );
					scene.add(line);
					segments.push(line);
				}
			};

			function onWindowResize() {

			};
			
			function resizeCanvasToDisplaySize() {
				// look up the size the canvas is being displayed
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				// adjust displayBuffer size to match
				if (canvas.width !== width || canvas.height !== height) {
					// you must pass false here or three.js sadly fights the browser
					renderer.setSize(width, height, false);
					camera.aspect = width / height;
					camera.updateProjectionMatrix();

					// update any render target sizes here
				}
			};
      
			function animate() {
				requestAnimationFrame( animate );
				render();
				// stats.update();
			};
			var toggle = 0;
			function render() {
				resizeCanvasToDisplaySize();
				var intersection = projectOnPlane(mouse);
				if ( toggle > 0.02 && intersection !== null ) {
					tailSpheres[ spheresIndex ].position.copy( intersection.point );
					tailSpheres[ spheresIndex ].scale.set( 1, 1, 1 );
					spheresIndex = ( spheresIndex + 1 ) % tailSpheres.length;
					toggle = 0;
				}
				for ( var i = 0; i < tailSpheres.length; i ++ ) {
					var sphere = tailSpheres[ i ];
					sphere.scale.multiplyScalar( 0.98 );
					sphere.scale.clampScalar( 0.01, 1 );
				}
        
				toggle += clock.getDelta();
				renderer.render( scene, camera );
			};
			
		</script>

	</body>

</html>